{"version":3,"sources":["App.js","index.js"],"names":["DATA","time","height","id","App","rows","React","useMemo","reduce","acc","elm","idx","push","currRow","accHeights","length","map","minAcc","Math","min","currMinIdx","indexOf","prevRow","midAcc","sort","a","b","currMidIdx","maxAcc","max","currMaxIdx","cols","innerRows","innerCols","forEach","row","groupByIdx","S","Container","Column","getImageElm","subProps","key","style","InnerImage","styled","div","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9f7688c3.chunk.js","sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\n\n\n/**\n *\n *\n *\n */\nconst DATA = [\n  { time: 250, height: 400, id: '01' },\n  { time: 240, height: 200, id: '02' },\n  { time: 230, height: 450, id: '03' },\n  { time: 220, height: 400, id: '04' },\n  { time: 210, height: 100, id: '05' },\n  { time: 200, height: 300, id: '06' },\n  { time: 190, height: 400, id: '07' },\n  { time: 180, height: 600, id: '08' },\n  { time: 170, height: 300, id: '09' },\n  { time: 160, height: 200, id: '10' },\n  { time: 150, height: 600, id: '11' },\n  { time: 150, height: 300, id: '12' },\n];\n\n\n/**\n *\n *\n *\n */\nexport default function App() {\n\n  const rows = React.useMemo(() => groupByRow(DATA), []);\n  const cols = React.useMemo(() => groupByIdx(rows), []);\n\n  return (\n    <S.Container>\n      {cols.map(getColumnElm)}\n    </S.Container>\n  );\n\n  /**\n   *\n   *\n   */\n  function getColumnElm(rows) {\n\n    return (\n      <S.Column>\n        {rows.map(getImageElm)}\n      </S.Column>\n    );\n  }\n\n  /**\n   *\n   *\n   *\n   */\n  function getImageElm(elm) {\n\n    const subProps = {\n      key: elm.id,\n      style: {height: elm.height},\n    };\n\n    return (\n      <S.InnerImage {...subProps}>\n        {elm.id}\n      </S.InnerImage>\n    );\n  }\n\n  /**\n   *\n   *\n   *\n   */\n  function groupByRow(innerData) {\n\n    return innerData.reduce((acc, elm, idx) => {\n\n      /**\n       *  initialize: first 3 elements will\n       *  always be positioned at the top\n       *\n       */\n      if (idx <= 2) {\n        acc[0] = acc[0] ?? [];\n        elm.acc = elm.height;\n        acc[0].push(elm);\n        return acc;\n      }\n\n      /**\n       *  idx modulo 3 equal 0, means\n       *  a new row is starting:\n\n          [\n            [400, 200, 500], <-- prevRow\n            []               <-- we are here\n          ]\n\n       *  find the min value index in prevRow\n       *  and place it in the same idx in currRow\n\n          [\n            [400, 200, 500], <-- it's 200 in idx 1\n            [   , XXX,    ], <-- so in idx 1 put XXX\n          ]\n       */\n      if (idx % 3 === 0) {\n\n        const prevRow = acc[acc.length - 1];\n        const currRow = [];\n\n        const accHeights = prevRow.map(elm => elm.acc);\n        const minAcc = Math.min(...accHeights);\n        const currMinIdx = accHeights.indexOf(minAcc);\n\n        elm.acc = elm.height + minAcc;\n        currRow[currMinIdx] = elm;\n        acc.push(currRow);\n        return acc;\n      }\n\n      /**\n       *  idx modulo 3 equal 1, means the\n       *  same as comment above. The real\n       *  only difference is find middle\n       *  value idx and insert it there\n\n          [\n            [400, 200, 500], <-- it's 400 in idx 0\n            [YYY, XXX,    ], <-- so in idx 1 put YYY\n          ]\n       */\n      if (idx % 3 === 1) {\n\n        const prevRow = acc[acc.length - 2];\n        const currRow = acc[acc.length - 1];\n\n        const accHeights = prevRow.map(elm => elm.acc);\n        const midAcc = [...accHeights].sort((a, b) => a - b)[1];\n        const currMidIdx = accHeights.indexOf(midAcc);\n\n        elm.acc = elm.height + midAcc;\n        currRow[currMidIdx] = elm;\n        return acc;\n      }\n\n      /**\n       *  finally, idx modulo 3 equal 2,\n       *  means find max value idx and\n       *  and insert curr element there\n\n          [\n            [400, 200, 500], <-- it's 500 in idx 0\n            [YYY, XXX, ZZZ], <-- so in idx 2 put ZZZ\n          ]\n       */\n      if (idx % 3 === 2) {\n\n        const prevRow = acc[acc.length - 2];\n        const currRow = acc[acc.length - 1];\n\n        const accHeights = prevRow.map(elm => elm.acc);\n        const maxAcc = Math.max(...accHeights);\n        const currMaxIdx = accHeights.indexOf(maxAcc);\n\n        elm.acc = elm.height + maxAcc;\n        currRow[currMaxIdx] = elm;\n        return acc;\n      }\n\n      return acc;\n    }, []);\n  }\n\n  /**\n   *  zip like function to transfrom,\n   *  it's basically a matrix rotation.\n   *  X => Y\n\n      X = [\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8],\n      ];\n\n      Y = [\n        [0, 3, 6],\n        [1, 4, 7],\n        [2, 5, 8],\n      ];\n   */\n  function groupByIdx(innerRows) {\n\n    const innerCols = [[], [], []];\n\n    innerRows.forEach(row => {\n      row.forEach((elm, idx) => {\n        innerCols[idx].push(elm);\n      });\n    });\n\n    return innerCols;\n  }\n}\n\n\n/**\n *\n *\n */\nconst S = {};\n\nS.Container = styled.div`\n  display: flex;\n  flex-direction: row;\n  width: 600px;\n`;\n\nS.Column = styled.div`\n  flex: 1;\n`;\n\nS.InnerImage = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: 10px;\n  border: 1px solid;\n  width: 200px;\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}